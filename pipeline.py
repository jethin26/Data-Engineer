# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zawr-IIpdBeFTWyFfLmRg42OwqUeBoJJ
"""

import os
import xml.etree.ElementTree as ET
from typing import List, Dict
import pandas as pd
from datetime import datetime
import sqlite3
import logging
import json  # Import json module for converting lists to JSON strings

logging.basicConfig(filename='pipeline.log', level=logging.INFO)

class RO:
    def __init__(self, order_id, date_time, status, cost, technician, repair_parts):
        self.order_id = order_id
        self.date_time = date_time
        self.status = status
        self.cost = cost
        self.technician = technician
        self.repair_parts = repair_parts

def read_files_from_dir(dir: str) -> List[str]:
    xml_files = []
    try:
        for file in os.listdir(dir):
            if file.endswith(".xml"):
                file_path = os.path.join(dir, file)
                #print(f"Reading file: {file_path}")
                with open(file_path, "r") as f:
                    content = f.read()
                    #print(f"File content: {content[:100]}...")  # Print first 100 characters for brevity
                    xml_files.append(content)
    except Exception as e:
        logging.error(f"Error reading files from directory: {e}")
    return xml_files

def parse_xml(files: List[str]) -> pd.DataFrame:
    data = []
    try:
        for xml_content in files:
            #print(f"Parsing XML content: {xml_content[:100]}...")  # Print first 100 characters for brevity
            try:
                root = ET.fromstring(f"<root>{xml_content}</root>")  # Wrap content in a root element
                for event in root.findall('event'):
                    order_id = event.find('order_id').text
                    date_time = datetime.strptime(event.find('date_time').text, '%Y-%m-%dT%H:%M:%S')
                    status = event.find('status').text
                    cost = float(event.find('cost').text)
                    technician = event.find('repair_details/technician').text
                    repair_parts = [(part.attrib['name'], int(part.attrib['quantity'])) for part in event.findall('repair_details/repair_parts/part')]

                    # Debug prints
                    '''print(f"Order ID: {order_id}")
                    print(f"Date Time: {date_time}")
                    print(f"Status: {status}")
                    print(f"Cost: {cost}")
                    print(f"Technician: {technician}")
                    print(f"Repair Parts: {repair_parts}")'''

                    data.append([order_id, date_time, status, cost, technician, repair_parts])
            except ET.ParseError as pe:
                logging.error(f"Error parsing XML content: {pe} - Content: {xml_content}")
    except Exception as e:
        logging.error(f"Error parsing XML files: {e}")
    # Check the data being appended
    #print(f"Data: {data}")
    return pd.DataFrame(data, columns=['order_id', 'date_time', 'status', 'cost', 'technician', 'repair_parts'])

def window_by_datetime(data: pd.DataFrame, window: str) -> Dict[str, pd.DataFrame]:
    windowed_data = {}
    try:
        data['date_time'] = pd.to_datetime(data['date_time'])
        data = data.sort_values(by='date_time', ascending=False)
        grouped = data.groupby(pd.Grouper(key='date_time', freq=window))
        for name, group in grouped:
            windowed_data[str(name)] = group
    except Exception as e:
        logging.error(f"Error windowing data: {e}")
    return windowed_data

def process_to_RO(data: Dict[str, pd.DataFrame]) -> List[RO]:
    RO_list = []
    try:
        for window, df in data.items():
            latest_event = df.iloc[0]
            ro = RO(latest_event['order_id'], latest_event['date_time'], latest_event['status'], latest_event['cost'], latest_event['technician'], latest_event['repair_parts'])
            RO_list.append(ro)
    except Exception as e:
        logging.error(f"Error processing data to RO format: {e}")
    return RO_list

def write_to_database(RO_list: List[RO], db_file: str):
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS repair_orders
                          (order_id TEXT, date_time TEXT, status TEXT, cost REAL, technician TEXT, repair_parts TEXT)''')
        for ro in RO_list:
            repair_parts_str = json.dumps(ro.repair_parts)  # Convert repair_parts list to JSON string
            cursor.execute('''INSERT INTO repair_orders (order_id, date_time, status, cost, technician, repair_parts)
                              VALUES (?, ?, ?, ?, ?, ?)''', (ro.order_id, ro.date_time.strftime('%Y-%m-%d %H:%M:%S'), ro.status, ro.cost, ro.technician, repair_parts_str))
        conn.commit()
        conn.close()
    except Exception as e:
        logging.error(f"Error writing to database: {e}")



def main():
    try:
        # Read XML files from directory
        xml_files = read_files_from_dir("/content/sample_data/data-engineer/data")

        # Parse XML files
        data = parse_xml(xml_files)
        #print(data)  # Debug print to check DataFrame content

        # Window data by date_time
        windowed_data = window_by_datetime(data, '1D')

        # Process data into structured RO format
        RO_list = process_to_RO(windowed_data)

        # Write output to SQLite database
        write_to_database(RO_list, "repair_orders.db")

        logging.info("Pipeline executed successfully")
    except Exception as e:
        logging.error(f"Pipeline execution failed: {e}")

if __name__ == "__main__":
    main()